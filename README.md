## 🧠 Jailbreak LLM Response Classifier

### Detection and analysis of responses generated by language models under adversarial prompts

> Bachelor’s Thesis Project - University of Milano-Bicocca
> **Francesco Bianchi** · A.Y. 2024/2025
> Supervisors: Prof. Claudio Ferretti, Prof.ssa Martina Saletta

---

## 📚 Project Background and Motivation

Large Language Models (LLMs) have demonstrated remarkable capabilities in generating coherent and contextually relevant text. However, they are vulnerable to **jailbreak prompts**—carefully crafted inputs designed to bypass alignment safeguards and elicit unintended or harmful responses. Ensuring the reliability and safety of LLMs is critical, especially as they are deployed in sensitive applications.

This project addresses the challenge of **automatically detecting** when an LLM response results from a jailbreak prompt. By combining **supervised learning** (fine-tuned BERT classification) with **unsupervised analysis** (clustering), we aim to provide both accurate detection and deeper insights into the ways models fail alignment.

---

## 🚀 Key Features and Highlights

1. **Binary Classification**:

   * Fine-tuned BERT model labels each response as **`jailbreak`** or **`non-jailbreak`**.
   * Confidence scores accompany each prediction for thresholding and analysis.

2. **Embedding Extraction**:

   * Utilize the `[CLS]` token embedding from BERT to obtain a high-dimensional semantic representation of each response.
   * Preserve rich contextual information critical for downstream analysis.

3. **Unsupervised Clustering**:

   * **Free K-means**: Automatically determine optimal `k` via **Silhouette Score** and **Elbow Method**.
   * **Hierarchical Clustering**: Multi-level grouping to reveal subcategories within `jailbreak` and `non-jailbreak` responses.

4. **Dimensionality Reduction & Visualization**:

   * **PCA** (linear overview)
   * **t-SNE** (local structure)
   * **UMAP** (global and local balance)
   * Generate 2D plots to visually assess cluster separation and structure.

5. **Reproducibility & Portability**:

   * Fully containerized Google Colab notebooks.
   * Standardized datasets and clear folder structure.
   * Automated pipelines for data loading, model inference, clustering, and visualization.

---

## 🗂 Folder Structure Overview

```bash
LLM_Response_Classifier/
├── CODE/
│   ├── FINAL_VERSIONS/
│   │   ├── free_clustering/
│   │   │   ├── Bert_tuned_cluster_e_valutazione.ipynb
│   │   │   ├── bert-no-tuned_cluster_e_valutazione.ipynb
│   │   │   └── TestBert_fine_tuning.ipynb
│   │   └── hierarchical_clustering/
│   │       ├── Bert_tuned_cluster_e_valutazione.ipynb
│   │       ├── bert-no-tuned_cluster_e_valutazione.ipynb
│   │       └── TestBert_fine_tuning.ipynb
│   └── PREVIOUS_STEPS/
│       ├── BER_Fine_Tuning_V1.ipynb
│       ├── comparative_tuned_vs_nontuned/
│       │   ├── Bert_cluster.ipynb
│       │   └── TestBert.ipynb
│       └── kmeans_k_equals_2/
│           ├── Bert_tuned_2cluster.ipynb
│           ├── bert-no-tuned_2cluster.ipynb
│           └── TestBert.ipynb
│
├── DATASETS/
│   ├── fine_tuning_and_test/
│   │   ├── dataset_completo.json
│   │   └── Test2.json
│   └── kmeans_evaluation/
│       ├── balanced/
│       │   ├── response.json
│       │   └── selected_responses.json
│       └── unbalanced/
│           ├── response.json
│           └── response-with_label.json
│
├── reports_and_findings/
│   ├── bert_tuned_vs_non_tuned/
│   │   ├── v1_CONFRONTO.pdf
│   │   └── v2_REL.pdf
│   ├── evaluator_reports/
│   │   ├── free_clustering/
│   │   │   ├── methods.pdf
│   │   │   └── results.pdf
│   │   └── hierarchical_clustering/
│   │       ├── methods.pdf
│   │       └── results.pdf
│   ├── fine_tuning_reports/
│   │   ├── code_evolution/
│   │   │   └── BERT_add_code_versions_1_to_5.pdf
│   │   └── test_results/
│   │       ├── bert_0.0_to_1.7.pdf
│   │       └── bert_test_1.8.pdf
│   ├── vector_embeddings/
│   │   ├── REL.pdf
│   │   └── rel_vettori.pdf
│   └── weekly_reports/
│       ├── week1.pdf
│       ├── week2.pdf
│       └── …
│       └── week7.pdf
│
├── FINAL_REPORT/
└── README.md
```

**Notes**:

* Notebooks in each subfolder are chronologically ordered.
* Clear separation between development (`PREVIOUS_STEPS`) and final deliverables (`FINAL_VERSIONS`).

---

## ⚙️ Installation & Setup

1. **Clone repository**:

   ```bash
   git clone https://github.com/your-username/LLM_Response_Classifier.git
   cd LLM_Response_Classifier
   ```

2. **Create virtual environment & install dependencies**:

   ```bash
   python3 -m venv venv
   source venv/bin/activate  # Linux/macOS
   venv\Scripts\activate   # Windows
   pip install --upgrade pip
   pip install -r requirements.txt
   ```

3. **Configure Paths** (if needed):

   * Update dataset paths in notebooks or scripts under `CODE/`.

4. **Run Notebooks**:

   * Open Google Colab and import the desired `.ipynb` file from `CODE/FINAL_VERSIONS/`.

---

## 🎯 Usage Examples

### 1. Fine-Tuning BERT (if re-training)

```python
from transformers import AutoModelForSequenceClassification, AutoTokenizer, Trainer, TrainingArguments

tokenizer = AutoTokenizer.from_pretrained('bert-base-uncased')
model = AutoModelForSequenceClassification.from_pretrained('bert-base-uncased')

# Prepare dataset and training args...
training_args = TrainingArguments(
    output_dir='./models/bert-finetuned',
    num_train_epochs=3,
    per_device_train_batch_size=16,
    evaluation_strategy='steps',
)
trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=train_dataset,
    eval_dataset=val_dataset,
)
trainer.train()
```

### 2. Embedding Extraction & Clustering

```python
from transformers import AutoModel, AutoTokenizer
from sklearn.cluster import KMeans
import torch

# Load fine-tuned model
model = AutoModel.from_pretrained('Teto03/Bert_base_fineTuned')
tokenizer = AutoTokenizer.from_pretrained('Teto03/Bert_base_fineTuned')

# Encode responses
tokenized = tokenizer(responses, padding=True, truncation=True, return_tensors='pt')
with torch.no_grad():
    outputs = model(**tokenized)
embeddings = outputs.last_hidden_state[:, 0, :].numpy()  # [CLS] embeddings

# Determine optimal k
kmeans = KMeans(n_clusters=3).fit(embeddings)
labels = kmeans.labels_
```

---

## 📈 Results & Insights

1. **Classification Performance**:

   * Fine-tuned BERT achieved **X% accuracy**, outperforming the base model by **Y%**.
   * Confusion matrices and ROC curves available in `reports_and_findings/bert_tuned_vs_non_tuned/`.

2. **Clustering Quality**:

   * Optimal cluster counts: `k=3` for fine-tuned, `k=2` for base model (Silhouette analysis).
   * Hierarchical clustering uncovered **Z subgroups** within jailbreak responses, suggesting thematic variations.

3. **Visualization**:

   * PCA and UMAP plots demonstrate clear separation between `jailbreak` and `non-jailbreak` clusters.
   * t-SNE highlights local structure, revealing tight clusters of similar response strategies.

---

## 📬 Contact & Collaboration

For questions, collaborations, or feedback, please reach out:

* **Email**: [frab22207@gmail.com](mailto:frab22207@gmail.com)

